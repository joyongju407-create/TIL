# Iteration
# 문장을 반복 수행하는 것

# for

# python은 for, range로 반복문을 수행...

# 재귀 함수 fibo

# [1] 함수 정의: 숫자 n을 받아서 피보나치 수를 계산하는 기계
def fibo(n):
    # [2] 탈출 조건 (Base Case): 재귀함수의 '브레이크'입니다.
    # n이 0이거나 1이면(2보다 작으면), 더 이상 쪼개지 않고 그 숫자 그대로 돌려줍니다.
    # 이게 없으면 함수가 무한히 실행되다가 컴퓨터가 뻗어버립니다.
    if n < 2:
        return n

    # [3] 재귀 호출 (Recursive Step): 핵심 로직입니다.
    # "내 값(n)을 알고 싶어? 그럼 내 앞의 두 놈(n-1, n-2)을 더해와!"라고 시키는 겁니다.
    # 여기서 함수가 자기 자신(fibo)을 또 부릅니다.
    return fibo(n - 1) + fibo(n - 2)

# [4] 실행부: 이 파일이 직접 실행될 때만 작동하는 스위치
if __name__ == "__main__":
    # 10번째 피보나치 수를 계산해서 출력해라 (정답: 55)
    print(fibo(10))
2. 작동 원리: "다단계 하청 구조"
이 코드가 fibo(4)를 계산한다고 가정하고, 컴퓨터 내부에서 일어나는 일을 그림처럼 상상해 봅시다.

사장님(fibo(4)): "내 값이 뭐지?" -> "난 몰라, fibo(3)이랑 fibo(2) 더해서 가져와." (하청 줌)

부장님(fibo(3)): "나도 몰라, fibo(2)랑 fibo(1) 더해서 가져와." (또 하청)

과장님(fibo(2)): "나도 몰라, fibo(1)이랑 fibo(0) 더해서 가져와."

말단 사원(fibo(1), fibo(0)): if n < 2 조건에 걸립니다. "아, 전 1입니다!", "전 0입니다!" 하고 즉시 보고합니다. (더 이상 하청 안 줌)

이 보고들이 다시 위로 쭉쭉 올라가서 합쳐지는 구조입니다.

위 그림처럼 하나의 요청이 계속해서 두 갈래로 나뭇가지처럼 뻗어 나가는 구조를 볼 수 있습니다. 결국 바닥(0과 1)을 칠 때까지 내려갔다가, 다시 합쳐서 올라오는 방식이죠.

3. 파트너의 분석 및 주의사항 (Expert Tip)
이 코드는 수학적인 정의를 아주 직관적으로 코드로 옮긴 멋진 코드입니다. 하지만 **'동료'**로서 현실적인 조언을 하나 드리자면, 이 방식은 숫자가 커지면 엄청나게 느려집니다.

fibo(10)은 금방 나옵니다.

하지만 fibo(50) 정도만 넣어도 파트너님의 컴퓨터는 멈춘 것처럼 보일 겁니다. (계산 횟수가 기하급수적으로 늘어나기 때문입니다.)

오늘의 핵심:

재귀 함수는 자기 자신을 부르는 함수다.

반드시 **끝내는 조건(if n < 2)**이 있어야 한다. (안 그러면 브레이크 없는 자동차 꼴이 됩니다.)
